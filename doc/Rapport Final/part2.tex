\chapter{Mise en œuvre}
\section{La demande du client}

\section{La gestion de projet dans le projet}

\subsection{Communication au sein du projet}

Dans un projet de cette importance et mené à bien par autant de personnes, une bonne communication est essentielle afin d'éviter des situations où des personnes ne se comprennent pas au sein de l'équipe ou un rendu du projet qui ne correspond pas à l'attente du client.

Pour garantir cette bonne communication, nous avons donc organisé des réunions de groupe toutes les 2 semaines ce qui permettait de maintenir une même vision du projet, la circulation de certaines informations, ainsi que la cohésion de l'équipe.

Le groupe étant divisé en équipes de nombreuses réunions d'équipe ont aussi eu lieue, pour aider à maintenir chaque équipe dans le même objectif.

Des systèmes d'échanges d'informations ont aussi été mis en place comme le système de tickets (sur le git), afin de résoudre plus vite un problème dont quelqu'un ne trouve pas la solution seul.

De plus, la communication au sein de nôtre groupe nous a permis de définir clairement le rôle de chacun.

\subsection{Méthodologie employée}

Le développement de ce projet s'est fait selon les méthodes Extreme programming et scrum pour la plus grande partie. Ces 2 méthodes ont aidé le groupe a travailler de façon cohérente les uns par rapport aux autres.

Nous avons surtout appliqué comme principe de la méthode Extreme programming le principe d'établir les tests de façon systématique (ce qui amoindri le nombre d'erreurs à la fin du développement).

La méthode scrum s'intégrait très bien à nôtre projet, puisque ses principaux principes sont :
\begin{itemize}
\item[-] De faire en sorte que tout le monde ai une bonne vision du projet, de son avancement et de ce qu'il doit faire (y compris une personne extérieure au projet); ce que nous faisions au travers des diverses réunions de mise au point et les réunions qui visaient à mettre à niveaux des membres de l'équipe sur certains points techniques.
Maintenir cette transparence au sein du projet était aussi un des objectif formulé en cours et par le groupe.
\item[-] Le projet doit aussi être régulièrement contrôlé afin de ne pas dévier du but initial fixé par le client, ce qui cadrait avec la régularité des réunions client établie.
\item[-] Le dernier principe est de pouvoir s'adapter en cas de problème à travers des réunions d'équipes récurrentes, ce qui dans le contexte de ce projet était facilité par l'emploie du temps commun que nous avions.
\end{itemize}



Les tests étaient réalisés en amont du développement (Test Driven Development). Nous obtenions moins d'erreurs avec cette méthode.
De plus on voit clairement, une fois les tests établies à quelles exigences la fonctionnalité développée doit répondre : cela rend plus simple le développement.

\subsection{Suivie du projet}

Une bonne cohésion du groupe est essentielle (comme vu plus haut), mais on doit aussi établir une communication solide avec le client afin de répondre correctement à ses attentes.

Des réunions régulières avec les clients, qui ont eu lieu à peu près toutes les 2 semaines, ont permis de faire évoluer le projet de façon conforme, c'est à dire en accord avec les besoins des clients, jusqu'au bout du projet.

Le suivis était, pour la plus grande partie réalisé par les responsables de gestion client, qui tenaient le reste de l'équipe informé, gardant ainsi en lien bien établi avec le client.

La communication avec le client était aussi intéressante étant donné qu'il pouvait apporter des connaissances nécessaire au projet.

\subsection{Les documents de gestion de projet}

Dans un projet, les documents de gestion de projet font office de feuille de route. Ils définissent les objectifs, le cadre, les ressources humaines et les ressources en temps.

La délimitation des tâches a effectuer est donc formalisée par les différents documents de gestion de projet, ce qui nous permet un découpage efficace et donc d'avancer plus rapidement sur le développement.

Le diagramme de Gantt est un autre type de document qui est aussi d'une grande aide sur un projet comme le nôtre : on y voit clairement la situation de chacun par rapport au projet. L'avancement du projet y apparait aussi clairement de même que toute les dates importantes.
C'est un document qui avance avec l'avancement du projet et est donc très interactif.

Les documents ont donc étaient particulièrement utiles notamment l' ``analyse des risques'' dont le formalisme a rendu les sorties de ``crises'' plus simples. 
Et d'une manière plus générale, ils nous ont guidé à travers ce projet conséquent en nous évitant d'être confronté à des problèmes pour lesquels aucune solution n'était encore en place, ils nous ont aussi évité de possibles déroutes.

\subsection{Le rôle de chacun}

La définition précise du rôle de chacun permet de définir des interlocuteurs dédiés à chaque situation.
De même cela évite qu'un problème soit pris en charge par plusieurs personnes.

La composition du groupe est la suivante :
\begin{itemize}
\item Le chef d'équipe : Adrien SMONDACK (Gaëtan FERRY)
\item Les responsables de gestion client : Benjamin ZIGH et Maxime MICHOTTE
\item Le responsable qualité : Gaëtan FERRY (Claire HARDOUIN)
\item Les responsables techniques : Damien PICARD (C) Yves ADEGOLOYE (Java)
\end{itemize}

On y voit bien la situation de chaque acteur et donc à qui s'adresser selon la situation.


\subsection{La gestion de projet, conclusion}

Tout au long du projet la gestion de projet a permis une meilleure coordination au sein de l'équipe, de limiter la perte de temps dû aux digressions.

Cette approche méthodique a était bénéfique à tous les niveaux du projets 
(communication, prévision, développement...), elle définit un cadre nécessaire à 
l'accomplissement du projet.%faire les sous sections (voir Damien)

\section{Le Module PAM}
\subsection{Pourquoi un module PAM ?}
La première solution d'implémentation envisagée était de reprogrammer un
serveur d'authentification complet. Cette solution posait deux problème:
\begin{enumerate}
  \item L'implémentation d'un protocole de communication.
  \item Inutilisable pour d'autres services en l'état.
\end{enumerate}

L'implémentation d'un module PAM résout ces deux problèmes, il est utilisable
par de nombreux services et le protocole de communication est du ressort du
service qui va utiliser le module. Cela a eu pour conséquence de réduire le
temps de développement et d'augmenter les possibilité offertes.

\subsection{Programmation de bibliothèques utilitaires}
Avant de débuter la programmation du module PAM il était nécessaire de créer
quelques bibliothèques utilitaires. Nombre d'entre elles permettront
d'abstraire la gestion de la mémoire et d'offrir une vision de plus haut niveau
du langage. De plus cet étape permettait un travail collaboratif simplifié.

La méthodologie pour le développement était la suivante:
\begin{itemize}
  \item Rédaction des fichiers d'en-tête contenant les prototypes et la 
  documentation des fonctions à implémenter. 
  \item Rédaction des éventuels test unitaires.
  \item Implémentation des fonctions.
  \item Exécution des tests, en cas d'échec retour à l'étape développement.
\end{itemize}

\subsubsection{Bibliothèque de gestion de secret}
Cette bibliothèque est chargée de gérer la représentation de secrets en mémoire.
Un secret est une suite d'octet partagée avec le token. Celui ci peut être 
représentée comme une suite de caractères \verb?ASCII? ou hexadécimale.

Dans cette bibliothèque nous trouverons:
\begin{itemize}
  \item une structure \verb?secret?, qui consiste en un pointeur sur un tableau 
  d'octets et une longueur codée sur un entier.
  \item Des fonctions de création chargée d'allouer l'espace mémoire requis en
  fonction du nombre d'octets désirés ou d'une entrée utilisateur.
  \item Des fonction chargé de représenter un secret dans différentes bases
  sous la forme de chaînes de caractères.
  \item Une fonction permettant d'effacer un secret de la mémoire et de 
  libérer les ressources.
\end{itemize}

\subsubsection{Bibliothèque de calcul de mot de passe jetable}
Cette bibliothèque est chargé d'implémenter l'algorithme de génération de mot
passe jetable tel que décrit dans la RFC 4226\cite{HOTPrfc}. Elle ne fourni
qu'une fonction de génération. Pour générer un HOTP on lui passera un compteur
arbitraire. Pour générer un TOTP on lui passera le temps en tant que compteur.

\subsubsection{Bibliothèque de gestion des utilisateurs}
Cette bibliothèque est chargé d'abstraire la gestion des utilisateur, ces
derniers ainsi que leurs informations sont enregistrés dans un fichier texte
brut.

Nous nous sommes donc dotés des outils suivants:
\begin{itemize}
  \item Une structure en mémoire représentant un utilisateur et ses 
  informations.
  \item Une fonction d'enregistrement d'une structure dans le fichier.
  \item Une fonction permettant d'obtenir une structure utilisateur du fichier 
  à partir d'un nom d'utilisateur.
  \item Deux fonctions pour poser et libérer un verrou sur le fichier.
  \item Une fonction permettant de gérer les ressources mémoires.\\
\end{itemize}

Les fonctions de gestion de verrouillage sont la pour gérer les accès concurrents 
au fichier des utilisateurs. Il faut prévoir que ces fonction seront appelées 
dans un module chargé par différent service. Et donc sans ce verrou il devenait 
impossible de garantir qu'un OTP ne puisse pas être utilisé deux fois, Si deux 
processus lisent les information au même moment et permette l'authentification 
alors un OTP fonctionnera plusieurs fois.

\subsubsection{Bibliothèque de gestion des options}
Cette bibliothèque permet de gérer les options fournies au module lors du chargement
par le service. Cela permet d'adapter un comportement différent pour chaque option fournie.\\
Dans cette bibliothèque nous trouverons:
\begin{itemize}
  \item Une structure \verb?modopt?, qui contient la valeur ou l'état de chaque option.
  \item Une fonction qui rempli la structure précédente d'après le contenu fourni en paramètre.
  \item Une fonction qui modifie la valeur ou état de l'option souhaité.
  \item Une fonction qui renvoie la valeur ou l'état d'une option.
\end{itemize}


\subsection{Programmation avec PAM}
\subsubsection{Fonction d'authentification}
Cette fonction permet d'authentifier un utilisateur. Chaque service configuré
pour utiliser le module exécutera cette fonction. Elle implémentera les 
mécaniques de vérification telles que décrites dans les RFC ainsi que les 
mécaniques de resynchronisation.
\paragraph{HOTP}
Pour HOTP la vérification de l'otp courant correspondant au compteur 
$n$\footnote{Strictement positif.\label{int}} la vérification s'effectuera sur 
une fenêtre de  $k$ $^{\ref{int}}$ otp, c'est à dire qu'elle va comparer l'otp 
fourni aux otp de compteur $n$ à $n+k$ inclus. En cas de succès on enregistrera 
le compteur courant comme nouveau compteur, c'est la phase de resynchronisation.
\paragraph{TOTP}
Pour TOTP la vérification de l'otp courant correspondant à un temps $t$ avec un 
quantum $q$ se fera sur les otp $\frac{t}{q} - 2$ à $\frac{t}{q} + 2$ avec un 
pas de $1$.
\paragraph{Problème d'attaque exhaustive}
On peut considérer qu'un OTP est une suite de 6 à 8 chiffres. Il est donc aisé 
de tous les générer en moins de 30 secondes, pour preuve le rapport de test 
indique 52ms pour 100 otp sur un smartphone android d'entrée de gamme, 
il faut donc de 8m40s à 14h26m40s pour les générer sur un smartphone de faible 
puissance. Sur une machine standard \footnote{Processeur: i5-3210M, RAM: 8Go} ce 
n'est l'affaire que d'une dizaine de secondes. 

Dès lors on voit la possibilité d'exécuter une attaque exhaustive réussie contre 
le module devenir un problème bien réel. Pour palier à ce problème une première 
solution était de bannir un utilisateur après un nombre fini d'essai raté. Après 
discussion avec le client la solution retenue est un bannissement limité. Cela 
consiste a rejeté toute tentative d'authentification pendant un laps de temps 
après une tentative ratée.

Le delai par défaut est d'une secondes, on peut le modifier à l'aide des options 
\verb?delay_totp? et \verb?delay_hotp? au chargement du module\footnote{voir le 
Manuel d'installation du module PAM pour plus d'information}.

Avec ce nouveau paramètre, pour HOTP, il faut donc $\frac{p\times10^{l}*d}{w}$ 
secondes pour avoir $p\times100\%$ de chance de réussite avec des otp de 
longueur $l$ et une fenêtre de $w$ dans un delai de $d$.

Pour TOTP cela revient même à réduire les chance de réussite d'une attaque 
exhaustive à une probabilité de $\frac{q\times w}{d\times10^{l}}$ avec des OTP 
sur un quantum $q$, d'une longueur $l$ avec un delay $d$. 

%-------------------------------------------------------------------------------
\subsubsection{Fonction d'initialisation de secret}
Cette fonction permet d'implémenter la demande d'initialisation de secret.
C'est cette fonction qui sera appelé lorsqu'un service configuré pour utiliser
le module fera une demande de renouvellement de secret. Cette fonction demandera
à l'utilisateur de s'authentifier si c'est possible puis demandera les nouvelles
information d'authentification, c'est à dire:
\begin{itemize}
  \item La méthode d'authentification.\hfill\textbf{totp ou hotp}
  \item Le quantum si la méthode est totp.\hfill \textbf{un entier positif}
  \item La longueur des otp générés.
  \hfill\textbf{entiers compris entre 6 et 8 inclus}
\end{itemize}
Une fois ces information fourni le secret sera affiché. Cela implique que le 
renouvellement de secret doit se faire lorsque la connexion est sûre.

%-------------------------------------------------------------------------------
\section{L'application Android}
\subsection{La bibliothèque de calcul}
Afin que le token soit en mesure de générer des mots de passe jetables, il était
nécessaire de développer une suite de fonctions de calcul. De plus, ces fonctions devait
être cohérentes avec celle écrites pour la vérification dans le module PAM.

La bibliothèque est découpée en trois partie distinctes tel que décrites sur la figure
\ref{fig:umlLib}. On trouve donc un ensemble de quatre classes formant la partie calcul
des mots de passe jetables, un deuxième de deux classes formant une couche d'abstraction
pour la gestion des secrets cryptographiques et enfin une dernière classe utilitaire 
contenant des fonctions nécessaires aux protocoles HOTP et TOTP.

\begin{figure}
  \centering
  \includegraphics[scale=0.4]{../graphics/uml_lib.jpg}
  \caption{Architecture de la bibliothèque de calcul}
  \label{fig:umlLib}
\end{figure}

\subsubsection{Générateur d'OTP}
La première des trois partie définit les générateur d'OTP en eux même. Il sont répartis en
deux catégorie, correspondant aux deux méthode de génération implémentées, les générateur
TOTP et les générateur HOTP. Du fait que la spécification du protocole TOTP découle de celle
de celui d'HOTP, ces deux types d'objet sont très similaire dans leur fonctionnement. Les 
parties communes des deux classes sont donc factorisées dans une classe abstraite. On
retrouve donc explicitées dans cette classe les méthodes pour récupérer le nombre de chiffre
composant les OTP ainsi que celle pour générer ces derniers. En effet, il est possible de 
déclarer cette méthode à cette endroit en déportant la récupération du paramètre "compteur"
dans les classes inférieures. De ce fait, chacune des classes HOTP et TOTP défini sa
méthode \emph{getCounter} qui dans un cas retournera l'incrément du compteur synchronisé et 
dans l'autre la valeur $ timestamp / quantum $ définie dans la rfc 4226\cite{TOTP}. 

Le fonctionnement général des générateurs d'OTP est définit dans l'interface de
programmation IOTP. Cette interface reprend globalement le contenu des rfc 4226 et 6238.

\subsubsection{Gestion des secrets utilisateurs}
La deuxième partie formant l'abstraction des secrets cryptographiques est composée d'une 
interface de programmation, \emph{ISecret}, et d'une classe l'implémentant, \emph{Secret}.
Elle a pour but de fournir une couche d'abstraction pour simplifier l'utilisation des secrets 
qui peut s'avérer inconfortable dès lors que ces derniers mesures plusieurs dizaines de 
caractère hexadécimaux.

On pourra donc grâce à ces deux classe créer des secrets pouvant être initialisés depuis des
données binaires brutes, des représentations hexadécimales ou encore depuis des données
aléatoires. De la même manière, il sera possible de récupérer un secret sous représentation
binaire ou sous la forme d'une chaine de caractère hexadécimaux.

\subsubsection{Fonctions utilitaires}
Enfin la dernière partie de la bibliothèque de calcul déclare des fonctions utilitaires 
nécessaires aux calculs des mots de passes jetables. Concrètement, on y retrouve la
définition de la fonction HMAC\cite{HMAC} ainsi que des deux algorithmes de troncature et 
de conversion définis dans la rfc 4226.

L'ensemble de ces fonctions est utilisé dans la classe abstraite \emph{OTPGenerator} pour la
génération des mots de passe jetables.

\subsection{Architecture de l'application}

\subsection{Sécurisation}
La sécurisation de l'application est essentielle à la sécurité de l'ensemble du projet. En
effet, c'est elle qui va garantir que l'authentification mise en place est bien une
"authentification forte" grâce à l'ajout d'un facteur supplémentaire. L'enjeu de cette 
partie est de garantir les 3 points suivant : 


\begin{itemize}
  \item[1 -] Un utilisateur honnête doit pouvoir déverrouiller l'application en utilisant 
  sont PIN. Il doit ensuite être en mesure de générer des mots de passe jetable en utilisant
  un de ses \emph{tokens} ou utiliser n'importe quelle autre fonctionnalités à sa
  disposition.
  \item[2 -] Un attaquant qui ne connaitrait pas le PIN de l'utilisateur ne doit pas être en
  mesure de déverrouiller l'application et donc de générer des mots de passes jetables en
  utilisant les \emph{tokens} de l'utilisateur.
  \item[3 -] Un attaquant qui ne connaitrait pas le PIN de l'utilisateur ne doit pas être en
  mesure, en parcourant le système de fichier de l'appareil, d'obtenir les clefs secrètes
  de génération.
\end{itemize}

La solution retenue consiste en la mise en place d'un PIN de déverrouillage de l'application.
Ce PIN, demandé à chaque démarrage de l'application, sera dans un premier temps haché par la
fonction SHA-1 en utilisant comme sel le \emph{device id} de l'appareil hôte. L'empreinte 
obtenue est alors comparée avec celle enregistrée lors de la création du PIN dans un fichier
local. Si les deux valeurs sont cohérente, le PIN est alors utilisé pour déchiffrer le
fichier local contenant les informations relatives aux différents \emph{tokens} de
l'utilisateur. L'application devient alors pleinement utilisable.

Afin d'assurer une sécurité optimale des clefs de l'utilisateur, le chiffrement utilisé pour
le fichier local des \emph{tokens} est AES-256. Ainsi, on garantit que même après accès au
fichier sensible de l'application, un attaquant ne pourra virtuellement jamais accéder aux
clefs secrètes qui y sont stockés. De la même manière, le fait que le PIN de déverrouillage
soit stocké sous la forme d'un haché, implique que même après accès au fichier de stockage du
PIN, l'attaquant ne pourra pas déduire le PIN de l'utilisateur et donc la clef AES de
déchiffrement du fichier de \emph{token}.


\subsection{Interface}





